//go:build !ignore_autogenerated_keepalive
// +build !ignore_autogenerated_keepalive

// Code generated by ___1go_build_github_com_ravinggo_tools_keepalive_gen. DO NOT EDIT.

package output

import (
	unsafe "unsafe"

	keepalive "github.com/ravinggo/tools/keepalive-gen/keepalive"
)

func (d *UserData) GetUserReadOnly() *User {
	index := d.UserKAIndex()
	i := d.DUsed[index]
	var e *keepalive.KAElem
	if i == -1 {
		e, i = d.AddData()
		d.DUsed[index] = i
	} else {
		e = &d.Data[i]
	}
	if e.State > keepalive.KAStateDelete {
		return (*User)(e.Data)
	}
	return &d.user
}
func (d *UserData) GetUser() *User {
	index := d.UserKAIndex()
	i := d.DUsed[index]
	var e *keepalive.KAElem
	if i == -1 {
		e, i = d.AddData()
		d.DUsed[index] = i
	} else {
		e = &d.Data[i]
	}
	if e.State > keepalive.KAStateDelete {
		return (*User)(e.Data)
	}
	x := d.user.DeepCopy()
	e.Data = unsafe.Pointer(x)
	e.State = keepalive.KAStateRead

	return x
}
func (d *UserData) SaveUser() {
	index := d.UserKAIndex()
	i := d.DUsed[index]
	var e *keepalive.KAElem
	if i == -1 {
		e, i = d.AddData()
		d.DUsed[index] = i
	} else {
		e = &d.Data[i]
	}

	if e.State == keepalive.KAStateReset {
		panic("no Get,but Save")
	}
	e.State = keepalive.KAStateSave
	if e.Wrote == 0 {
		e.Wrote = 1
		e.WriteIndex = index
		d.WI = append(d.WI, index)
	}
}
func SwapUserDataUser(d *UserData, p unsafe.Pointer) {
	u := (*User)(p)
	d.user.ResetNoSelf()
	d.user = *u
	u.ResetOnlySelf()
}

func (d *UserData) GetItem(id int64) (Item, bool) {
	index := d.ItemKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(da *Item) bool {
			return da.ID == id
		},
	)
	if state != 0 {
		return *v, state == 1
	}
	origin, ok := d.items[id]
	return origin, ok
}

func (d *UserData) RangeItems(f func(k int64, v Item) bool) {
	index := d.ItemKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for k, v := range d.items {
			if !f(k, v) {
				break
			}
		}
	} else {
		m := make(map[int64]*keepalive.KAElem, len(*kas))
		for i, v := range *kas {
			if v.NoOrigin != 0 {
				if v.State == keepalive.KAStateSave {
					temp := (*Item)(v.Data)
					if !f(temp.ID, *temp) {
						return
					}
				} else if v.State == keepalive.KAStateDelete {
					continue
				}
			}
			temp := (*Item)(v.Data)
			m[temp.ID] = &(*kas)[i]
		}
		for k, v := range d.items {
			if newV, ok := m[k]; ok {
				if newV.State != keepalive.KAStateDelete {
					if !f(k, *(*Item)(newV.Data)) {
						break
					}
				}
			} else {
				if !f(k, v) {
					break
				}
			}
		}
	}
}

func (d *UserData) SaveItem(v Item) {
	index := d.ItemKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := v.ID
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *Item) bool {
			return da.ID == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		*(*Item)(e.Data) = v
		return
	}
	var noOrigin int32
	if _, ok = d.items[id]; !ok {
		noOrigin = 1
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(v.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}

func (d *UserData) DeleteItem(id int64) {
	index := d.ItemKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *Item) bool {
			return da.ID == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := d.items[id]
	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}

func (d *UserData) LenItem() int {
	index := d.ItemKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count := len(d.items)
	if len(*kas) > 0 {
		for _, v := range *kas {
			if v.State == keepalive.KAStateSave && v.NoOrigin != 0 {
				count++
			} else if v.State == keepalive.KAStateDelete && v.NoOrigin == 0 {
				count--
			}
		}
	}
	return count
}

func SwapUserDataItem(d *UserData, p unsafe.Pointer) {
	u := (*Item)(p)
	old, ok := d.items[u.ID]
	if ok {
		old.ResetNoSelf()
		d.items[u.ID] = *u
	} else {
		d.items[u.ID] = *u
	}
	u.ResetOnlySelf()
}

func DeleteUserDataItem(d *UserData, p unsafe.Pointer) {
	u := (*Item)(p)
	old, ok := d.items[u.ID]
	if ok {
		delete(d.items, u.ID)
		old.ResetNoSelf()
	}
	u.Reset()
}

func (d *UserData) GetPlayer(id int64) (*Player, bool) {
	index := d.PlayerKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(da *Player) bool {
			return da.PID == id
		},
	)
	if state != 0 {
		return v, state == 1
	}
	origin, ok := d.playerMap[id]
	if !ok {
		return nil, false
	}
	v = origin.DeepCopy()
	*kas = append(
		*kas, keepalive.KAElem{
			Data:  unsafe.Pointer(v),
			State: keepalive.KAStateRead,
		},
	)
	return v, ok
}

func (d *UserData) RangePlayers(f func(k int64, v *Player) bool) {
	index := d.PlayerKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for k, v := range d.playerMap {
			if !f(k, v) {
				break
			}
		}
	} else {
		m := make(map[int64]*keepalive.KAElem, len(*kas))
		for i, v := range *kas {
			if v.NoOrigin != 0 {
				if v.State == keepalive.KAStateSave {
					temp := (*Player)(v.Data)
					if !f(temp.PID, temp) {
						return
					}
				} else if v.State == keepalive.KAStateDelete {
					continue
				}
			}
			item := (*Player)(v.Data)
			m[item.PID] = &(*kas)[i]
		}
		for k, v := range d.playerMap {
			if newV, ok := m[k]; ok {
				if newV.State != keepalive.KAStateDelete {
					if !f(k, (*Player)(newV.Data)) {
						break
					}
				}
			} else {
				if !f(k, v) {
					break
				}
			}
		}
	}
}

func (d *UserData) SavePlayer(v *Player) {
	index := d.PlayerKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := v.PID
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *Player) bool {
			return da.PID == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		e.Data = unsafe.Pointer(v)
		return
	}
	var noOrigin int32
	if _, ok = d.playerMap[id]; !ok {
		noOrigin = 1
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(v.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}

func (d *UserData) DeletePlayer(id int64) {
	index := d.PlayerKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *Player) bool {
			return da.PID == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := d.playerMap[id]
	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}

func (d *UserData) LenPlayer() int {
	index := d.PlayerKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count := len(d.playerMap)
	if len(*kas) > 0 {
		for _, v := range *kas {
			if v.State == keepalive.KAStateSave && v.NoOrigin != 0 {
				count++
			} else if v.State == keepalive.KAStateDelete && v.NoOrigin == 0 {
				count--
			}
		}
	}
	return count
}

func SwapUserDataPlayer(d *UserData, p unsafe.Pointer) {
	u := (*Player)(p)
	old, ok := d.playerMap[u.PID]
	if ok {
		d.playerMap[u.PID] = u
		old.Reset()
	} else {
		d.playerMap[u.PID] = u
	}
}

func DeleteUserDataPlayer(d *UserData, p unsafe.Pointer) {
	u := (*Player)(p)
	old, ok := d.playerMap[u.PID]
	if ok {
		delete(d.playerMap, u.PID)
		old.Reset()
	}
}

func (d *UserData) GetHistory(id int) (History, bool) {
	index := d.HistoryKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(v *History) bool {
			return v.A == id
		},
	)
	if state != 0 {
		return *v, state == 1
	}

	for _, v := range d.histories {
		if v.A == id {
			return v, true
		}
	}

	return History{}, false
}

func (d *UserData) RangeHistorys(f func(v *History) bool) {
	index := d.HistoryKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for i := range d.histories {
			if !f(&d.histories[i]) {
				break
			}
		}
	} else {
		m := make(map[int]*keepalive.KAElem, len(*kas))
		for i, v := range *kas {
			if v.NoOrigin != 0 {
				if v.State == keepalive.KAStateSave {
					temp := (*History)(v.Data)
					if !f(temp) {
						return
					}
				} else if v.State == keepalive.KAStateDelete {
					continue
				}
			}
			item := (*History)(v.Data)
			m[item.A] = &(*kas)[i]
		}
		for i := range d.histories {
			v := &d.histories[i]
			if newV, ok := m[v.A]; ok {
				if newV.State != keepalive.KAStateDelete {
					if !f((*History)(newV.Data)) {
						break
					}
				}
			} else {
				if !f(v) {
					break
				}
			}
		}
	}
}

func (d *UserData) SaveHistory(save History) {
	index := d.HistoryKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := save.A
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *History) bool {
			return v.A == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		return
	}
	noOrigin := int32(1)
	for _, v := range d.histories {
		if v.A == id {
			noOrigin = 0
			break
		}
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(save.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}

func (d *UserData) DeleteHistory(id int) {
	index := d.HistoryKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *History) bool {
			return v.A == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.WriteIndex == 0 {
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
			e.Wrote = 1
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := keepalive.SliceFind(
		d.histories, func(v *History) bool {
			return v.A == id
		},
	)

	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}

func (d *UserData) LenHistory() int {
	index := d.HistoryKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count := len(d.histories)
	if len(*kas) > 0 {
		for _, v := range *kas {
			if v.State == keepalive.KAStateSave && v.NoOrigin != 0 {
				count++
			} else if v.State == keepalive.KAStateDelete && v.NoOrigin == 0 {
				count--
			}
		}
	}
	return count
}

func SwapUserDataHistory(d *UserData, pointer unsafe.Pointer) {
	newV := (*History)(pointer)
	old, ok := keepalive.SliceFind(
		d.histories, func(v *History) bool {
			return v.A == newV.A
		},
	)
	if ok {
		*old = *newV
	} else {
		d.histories = append(d.histories, *newV)
	}
	newV.Reset()
}

func DeleteUserDataHistory(d *UserData, pointer unsafe.Pointer) {
	newV := (*History)(pointer)
	newSV, ok := keepalive.SwapDelete(
		d.histories, func(v *History) bool {
			if v.A == newV.A {
				return true
			}
			return false
		},
	)
	if ok {
		d.histories = newSV
	}
	newV.Reset()
}

func (d *UserData) GetDomain(id int64) (*Domain, bool) {
	index := d.DomainKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(v *Domain) bool {
			return v.A == id
		},
	)
	if state != 0 {
		return v, state == 1
	}

	origin, ok := keepalive.SliceFind(
		d.domains, func(v *Domain) bool {
			return v.A == id
		},
	)
	if !ok {
		return nil, false
	}
	v = origin.DeepCopy()
	*kas = append(
		*kas, keepalive.KAElem{
			Data:  unsafe.Pointer(v),
			State: keepalive.KAStateRead,
		},
	)
	return v, true
}

func (d *UserData) RangeDomains(f func(v *Domain) bool) {
	index := d.DomainKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for i := range d.domains {
			if !f(&d.domains[i]) {
				break
			}
		}
	} else {
		m := make(map[int64]*keepalive.KAElem, len(*kas))
		for i, v := range *kas {
			if v.NoOrigin != 0 {
				if v.State == keepalive.KAStateSave {
					temp := (*Domain)(v.Data)
					if !f(temp) {
						return
					}
				} else if v.State == keepalive.KAStateDelete {
					continue
				}
			}
			item := (*Domain)(v.Data)
			m[item.A] = &(*kas)[i]
		}
		for i := range d.domains {
			v := &d.domains[i]
			if newV, ok := m[v.A]; ok {
				if newV.State != keepalive.KAStateDelete {
					if !f((*Domain)(newV.Data)) {
						break
					}
				}
			} else {
				if !f(v) {
					break
				}
			}
		}
	}
}

func (d *UserData) SaveDomain(save *Domain) {
	index := d.DomainKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := save.A
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *Domain) bool {
			return v.A == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		return
	}
	noOrigin := int32(1)
	for _, v := range d.domains {
		if v.A == id {
			noOrigin = 0
			break
		}
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(save.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}

func (d *UserData) LenDomain() int {
	index := d.DomainKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count := len(d.domains)
	if len(*kas) > 0 {
		for _, v := range *kas {
			if v.State == keepalive.KAStateSave && v.NoOrigin != 0 {
				count++
			} else if v.State == keepalive.KAStateDelete && v.NoOrigin == 0 {
				count--
			}
		}
	}
	return count
}

func (d *UserData) DeleteDomain(id int64) {
	index := d.DomainKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *Domain) bool {
			return v.A == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.WriteIndex == 0 {
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
			e.Wrote = 1
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := keepalive.SliceFind(
		d.domains, func(v *Domain) bool {
			return v.A == id
		},
	)

	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}

func SwapUserDataDomain(d *UserData, pointer unsafe.Pointer) {
	newV := (*Domain)(pointer)
	old, ok := keepalive.SliceFind(
		d.domains, func(v *Domain) bool {
			if v.A == newV.A {
				v.ResetNoSelf()
				return true
			}
			return false
		},
	)
	if ok {
		*old = *newV
	} else {
		d.domains = append(d.domains, *newV)
	}
	newV.ResetOnlySelf()
}

func DeleteUserDataDomain(d *UserData, pointer unsafe.Pointer) {
	newV := (*Domain)(pointer)
	newSV, ok := keepalive.SwapDelete(
		d.domains, func(v *Domain) bool {
			if v.A == newV.A {
				v.ResetNoSelf()
				return true
			}
			return false
		},
	)
	if ok {
		d.domains = newSV
	}
	newV.Reset()
}

func (d *UserData) GetFight(id int64) (*Fight, bool) {
	index := d.FightKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(v *Fight) bool {
			return v.A == id
		},
	)
	if state != 0 {
		return v, state == 1
	}

	origin, ok := keepalive.SliceFindPtr(
		d.fights, func(v *Fight) bool {
			return v.A == id
		},
	)
	if !ok {
		return nil, false
	}
	v = origin.DeepCopy()
	*kas = append(
		*kas, keepalive.KAElem{
			Data:  unsafe.Pointer(v),
			State: keepalive.KAStateRead,
		},
	)
	return v, true
}

func (d *UserData) RangeFights(f func(v *Fight) bool) {
	index := d.FightKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for i := range d.fights {
			if !f(d.fights[i]) {
				break
			}
		}
	} else {
		m := make(map[int64]*keepalive.KAElem, len(*kas))
		for i, v := range *kas {
			if v.NoOrigin != 0 {
				if v.State == keepalive.KAStateSave {
					temp := (*Fight)(v.Data)
					if !f(temp) {
						return
					}
				} else if v.State == keepalive.KAStateDelete {
					continue
				}
			}
			item := (*Fight)(v.Data)
			m[item.A] = &(*kas)[i]
		}
		for i := range d.fights {
			v := d.fights[i]
			if newV, ok := m[v.A]; ok {
				if newV.State != keepalive.KAStateDelete {
					if !f((*Fight)(newV.Data)) {
						break
					}
				}
			} else {
				if !f(v) {
					break
				}
			}
		}
	}
}

func (d *UserData) SaveFight(save *Fight) {
	index := d.FightKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := save.A
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *Fight) bool {
			return v.A == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		return
	}
	noOrigin := int32(1)
	for _, v := range d.fights {
		if v.A == id {
			noOrigin = 0
			break
		}
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(save.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}

func (d *UserData) LenFight() int {
	index := d.FightKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count := len(d.fights)
	if len(*kas) > 0 {
		for _, v := range *kas {
			if v.State == keepalive.KAStateSave && v.NoOrigin != 0 {
				count++
			} else if v.State == keepalive.KAStateDelete && v.NoOrigin == 0 {
				count--
			}
		}
	}
	return count
}

func (d *UserData) DeleteFight(id int64) {
	index := d.FightKAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *Fight) bool {
			return v.A == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.WriteIndex == 0 {
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
			e.Wrote = 1
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := keepalive.SliceFindPtr(
		d.fights, func(v *Fight) bool {
			return v.A == id
		},
	)

	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}

func SwapUserDataFight(d *UserData, pointer unsafe.Pointer) {
	newV := (*Fight)(pointer)
	index := keepalive.SliceFindIndex(
		d.fights, func(v *Fight) bool {
			if v.A == newV.A {
				return true
			}
			return false
		},
	)
	if index > 0 {
		old := d.fights[index]
		d.fights[index] = newV
		old.Reset()
	} else {
		d.fights = append(d.fights, newV)
	}
}

func DeleteUserDataFight(d *UserData, pointer unsafe.Pointer) {
	newV := (*Fight)(pointer)
	newSV, ok := keepalive.SwapDeletePtr(
		d.fights, func(v *Fight) bool {
			if v.A == newV.A {
				v.Reset()
				return true
			}
			return false
		},
	)
	if ok {
		d.fights = newSV
	}
	newV.Reset()
}
func (d *UserData) UserKAIndex() int64 {
	return 0
}

var SaveUserDataFuncSlice = [...]func(*UserData, unsafe.Pointer){
	0: SwapUserDataUser,
}
var ResetUserDataFuncSlice = [...]func(unsafe.Pointer){
	0: func(pointer unsafe.Pointer) {
		(*User)(pointer).Reset()
	},
}
var indexTypeUserData = [...]int{
	-1,
}

func (d *UserData) DomainKAIndex() int64 {
	return 0
}
func (d *UserData) FightKAIndex() int64 {
	return 1
}
func (d *UserData) HistoryKAIndex() int64 {
	return 2
}
func (d *UserData) ItemKAIndex() int64 {
	return 3
}
func (d *UserData) PlayerKAIndex() int64 {
	return 4
}

var SaveSliceUserDataFuncSlice = [...]func(*UserData, unsafe.Pointer){
	0: SwapUserDataDomain,
	1: SwapUserDataFight,
	2: SwapUserDataHistory,
	3: SwapUserDataItem,
	4: SwapUserDataPlayer,
}
var DeleteSliceUserDataFuncSlice = [...]func(*UserData, unsafe.Pointer){
	0: DeleteUserDataDomain,
	1: DeleteUserDataFight,
	2: DeleteUserDataHistory,
	3: DeleteUserDataItem,
	4: DeleteUserDataPlayer,
}
var ResetSliceUserDataFuncSlice = [...]func(unsafe.Pointer){
	0: func(pointer unsafe.Pointer) {
		(*Domain)(pointer).Reset()
	},
	1: func(pointer unsafe.Pointer) {
		(*Fight)(pointer).Reset()
	},
	2: func(pointer unsafe.Pointer) {
		(*History)(pointer).Reset()
	},
	3: func(pointer unsafe.Pointer) {
		(*Item)(pointer).Reset()
	},
	4: func(pointer unsafe.Pointer) {
		(*Player)(pointer).Reset()
	},
}

func (d *UserData) Init() {
	if d.DUsed == nil {
		d.DUsed = make([]int, len(indexTypeUserData))
	}
	if d.SDUsed == nil {
		d.SDUsed = make([]int, len(indexSliceTypeUserData))
	}
	d.ClearKeepalive()
	d.domains = make([]Domain, 0, 16)
	d.fights = make([]*Fight, 0, 16)
	d.histories = make([]History, 0, 16)
	d.items = make(map[int64]Item, 16)
	d.playerMap = make(map[int64]*Player, 16)
}

var indexSliceTypeUserData = [...]int{
	-1, -1, -1, -1, -1,
}

func (d *UserData) ClearKeepalive() {
	d.KeepAlive.Clear(indexSliceTypeUserData[:], indexTypeUserData[:])
}

func (d *UserData) Commit() {
	for _, e := range d.Data {
		if e.State == keepalive.KAStateSave {
			SaveUserDataFuncSlice[e.WriteIndex](d, e.Data)
		} else {
			ResetUserDataFuncSlice[e.WriteIndex](e.Data)
		}
	}

	for _, es := range d.SliceData {
		for _, e := range es {
			if e.State == keepalive.KAStateSave {
				SaveSliceUserDataFuncSlice[e.WriteIndex](d, e.Data)
			} else if e.State == keepalive.KAStateDelete {
				DeleteSliceUserDataFuncSlice[e.WriteIndex](d, e.Data)
			} else {
				ResetSliceUserDataFuncSlice[e.WriteIndex](e.Data)
			}
		}
	}
	d.ClearKeepalive()
}

func (d *UserData) Rollback() {
	for _, e := range d.Data {
		ResetUserDataFuncSlice[e.WriteIndex](e.Data)
	}

	for _, es := range d.SliceData {
		for _, e := range es {
			ResetSliceUserDataFuncSlice[e.WriteIndex](e.Data)
		}
	}
	d.ClearKeepalive()
}

type DBUserDataInterface interface {
	SaveUser(isNew bool, d *User) error
	SaveDomain(isNew bool, d *Domain) error
	DeleteDomain(d *Domain) error
	SaveFight(isNew bool, d *Fight) error
	DeleteFight(d *Fight) error
	SaveHistory(isNew bool, d *History) error
	DeleteHistory(d *History) error
	SaveItem(isNew bool, d *Item) error
	DeleteItem(d *Item) error
	SavePlayer(isNew bool, d *Player) error
	DeletePlayer(d *Player) error
}

var dbUserDataSliceFunc = [...]func(dbFace DBUserDataInterface, e *keepalive.KAElem) error{
	0: func(dbFace DBUserDataInterface, e *keepalive.KAElem) error {
		if e.State == keepalive.KAStateSave {
			return dbFace.SaveDomain(e.NoOrigin != 0, (*Domain)(e.Data))
		} else if e.State == keepalive.KAStateDelete {
			return dbFace.DeleteDomain((*Domain)(e.Data))
		}
		return nil
	},

	1: func(dbFace DBUserDataInterface, e *keepalive.KAElem) error {
		if e.State == keepalive.KAStateSave {
			return dbFace.SaveFight(e.NoOrigin != 0, (*Fight)(e.Data))
		} else if e.State == keepalive.KAStateDelete {
			return dbFace.DeleteFight((*Fight)(e.Data))
		}
		return nil
	},

	2: func(dbFace DBUserDataInterface, e *keepalive.KAElem) error {
		if e.State == keepalive.KAStateSave {
			return dbFace.SaveHistory(e.NoOrigin != 0, (*History)(e.Data))
		} else if e.State == keepalive.KAStateDelete {
			return dbFace.DeleteHistory((*History)(e.Data))
		}
		return nil
	},

	3: func(dbFace DBUserDataInterface, e *keepalive.KAElem) error {
		if e.State == keepalive.KAStateSave {
			return dbFace.SaveItem(e.NoOrigin != 0, (*Item)(e.Data))
		} else if e.State == keepalive.KAStateDelete {
			return dbFace.DeleteItem((*Item)(e.Data))
		}
		return nil
	},

	4: func(dbFace DBUserDataInterface, e *keepalive.KAElem) error {
		if e.State == keepalive.KAStateSave {
			return dbFace.SavePlayer(e.NoOrigin != 0, (*Player)(e.Data))
		} else if e.State == keepalive.KAStateDelete {
			return dbFace.DeletePlayer((*Player)(e.Data))
		}
		return nil
	},
}
var dbUserDataFunc = [...]func(dbFace DBUserDataInterface, e *keepalive.KAElem) error{
	0: func(dbFace DBUserDataInterface, e *keepalive.KAElem) error {
		return dbFace.SaveUser(false, (*User)(e.Data))
	},
}

func (d *UserData) DoDB(dbFace DBUserDataInterface) error {
	for _, index := range d.WI {
		e := &d.Data[index]
		if err := dbUserDataFunc[index](dbFace, e); err != nil {
			return err
		}
	}

	for _, index := range d.WI {
		es := d.SliceData[index]
		for i := range es {
			e := &es[i]
			if err := dbUserDataSliceFunc[index](dbFace, e); err != nil {
				return err
			}
		}
	}
	return nil
}
