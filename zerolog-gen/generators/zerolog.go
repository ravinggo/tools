package generators

import (
	"io"
	"path"
	"path/filepath"
	"strings"

	"k8s.io/gengo/v2"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
	"k8s.io/klog/v2"

	"github.com/ravinggo/tools/zerolog-gen/args"
)

const (
	tagEnabledName = "game:zerolog-gen"
	IgnoreTag      = "ignore_autogenerated_zerolog"
)

func keepaliveNamer() *namer.NameStrategy {
	return &namer.NameStrategy{
		Join: func(pre string, in []string, post string) string {
			return strings.Join(in, "_")
		},
		PrependPackageNames: 1,
	}
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": keepaliveNamer(),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

type genZeroLog struct {
	generator.GoGenerator
	targetPackage string
	imports       namer.ImportTracker
}

type enabledTagValue struct {
	value    string
	register bool
}

func extractEnabledTypeTag(t *types.Type) *enabledTagValue {
	comments := append(append([]string{}, t.SecondClosestCommentLines...), t.CommentLines...)
	return extractEnabledTag(comments)
}

func extractEnabledTag(comments []string) *enabledTagValue {
	tagVals, ok := gengo.ExtractCommentTags("+", comments)[tagEnabledName]
	if ok {
		if len(tagVals) > 1 {
			klog.Fatalf("Found %d %s tags: %q", len(tagVals), tagEnabledName, tagVals)
		}
		if len(tagVals) == 1 {
			if tagVals[0] == "false" {
				return nil
			}
		}
	}
	// If there are multiple values, abort.

	// If we got here we are returning something.
	tag := &enabledTagValue{value: "true"}
	tag.register = true
	return tag
}

func GetTargets(context *generator.Context, args *args.Args) []generator.Target {
	boilerplate, err := gengo.GoBoilerplate(args.GoHeaderFile, IgnoreTag, gengo.StdGeneratedBy)
	if err != nil {
		klog.Fatalf("Failed loading boilerplate: %v", err)
	}

	targets := []generator.Target{}

	for _, i := range context.Inputs {
		klog.V(3).Infof("Considering pkg %q", i)

		pkg := context.Universe[i]
		pkgNeedsGeneration := false
		for _, t := range pkg.Types {
			klog.V(3).Infof("  considering type %q", t.Name.String())
			ttag := extractEnabledTypeTag(t)
			if ttag != nil && ttag.value == "true" {
				klog.V(3).Infof("    tag found")
				pkgNeedsGeneration = true
			}
		}
		if pkgNeedsGeneration {
			klog.V(3).Infof("Package %q needs generation", i)
			targets = append(
				targets,
				&generator.SimpleTarget{
					PkgName:       strings.Split(path.Base(pkg.Path), ".")[0],
					PkgPath:       pkg.Path,
					PkgDir:        pkg.Dir, // output pkg is the same as the input
					HeaderComment: boilerplate,
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
					GeneratorsFunc: func(c *generator.Context) (generators []generator.Generator) {
						return []generator.Generator{
							NewGenKeepAlive(args.OutputFile, pkg.Path, args.UsePool),
						}
					},
				},
			)
		}
	}
	return targets
}

func NewGenKeepAlive(outputFilename, targetPackage string, usePool bool) generator.Generator {
	dc := &genZeroLog{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		targetPackage: targetPackage,
	}
	dc.imports = generator.NewImportTrackerForPackage(
		targetPackage,
		&types.Type{Name: types.Name{Package: "github.com/ravinggo/objectpool"}},
		&types.Type{Name: types.Name{Package: "github.com/ravinggo/zerolog"}},
		&types.Type{Name: types.Name{Package: "github.com/mailru/easyjson/jwriter"}},
		&types.Type{Name: types.Name{Package: "github.com/mailru/easyjson/buffer"}},
	)
	return dc
}

func (g *genZeroLog) Imports(c *generator.Context) (imports []string) {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}
func (g *genZeroLog) isOtherPackage(pkg string) bool {
	if pkg == g.targetPackage {
		return false
	}
	if strings.HasSuffix(pkg, "\""+g.targetPackage+"\"") {
		return false
	}
	return true
}

func (g *genZeroLog) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

func (g *genZeroLog) Filter(c *generator.Context, t *types.Type) bool {
	// Filter out types not being processed or not copyable within the package.
	enabled := false
	ttag := extractEnabledTypeTag(t)
	if ttag != nil && ttag.value == "true" {
		enabled = true
	}
	if !enabled {
		return false
	}
	if t.Kind != types.Struct {
		return false
	}

	klog.V(3).Infof("Type %v is zerolog", t)
	return true
}

func (g *genZeroLog) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	if extractEnabledTypeTag(t) == nil {
		return nil
	}

	klog.V(2).Infof("Generating ZeroLog functions for type %v", t.Name.String())
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	TypePKGName := t.Name.Name
	if t.Name.Package != "" {
		TypePKGName = filepath.Base(t.Name.Package) + "." + t.Name.Name
	}
	args := generator.Args{
		"type":          t,
		"type_pkg_name": TypePKGName,
	}
	sw.Do(
		`
func (m *$.type|raw$) MarshalZerologObject(e*zerolog.Event)  {
	b:=objectpool.GetBytes(2048)
	defer objectpool.PutBytes(b)
	w := jwriter.Writer{Buffer: buffer.Buffer{Buf: b}}
	m.MarshalEasyJSON(&w)
	d,err:=w.BuildBytes()
	if err!=nil{
		e.Str("$.type_pkg_name$ error",err.Error())
	}else {
		e.RawJSON("$.type_pkg_name$",d)
	}
}
`,
		args,
	)
	return sw.Error()
}
