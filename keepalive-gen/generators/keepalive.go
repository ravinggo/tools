package generators

import (
	"fmt"
	"io"
	"path"
	"reflect"
	"sort"
	"strings"

	"github.com/huandu/xstrings"
	"k8s.io/gengo/v2"
	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/types"
	"k8s.io/klog/v2"

	"github.com/ravinggo/tools/keepalive-gen/args"
)

const (
	tagEnabledName = "game:keepalive-gen"
	IgnoreTag      = "ignore_autogenerated_keepalive"
	objectIDName   = "go.mongodb.org/mongo-driver/v2/bson.ObjectID"
)

func keepaliveNamer() *namer.NameStrategy {
	return &namer.NameStrategy{
		Join: func(pre string, in []string, post string) string {
			return strings.Join(in, "_")
		},
		PrependPackageNames: 1,
	}
}

// NameSystems returns the name system used by the generators in this package.
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"public": keepaliveNamer(),
		"raw":    namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the default name system for ordering the types to be
// processed by the generators in this package.
func DefaultNameSystem() string {
	return "public"
}

type genKeepAlive struct {
	generator.GoGenerator
	targetPackage string
	imports       namer.ImportTracker
	usePool       bool
	useMongo      bool
}

type enabledTagValue struct {
	value    string
	register bool
}

func extractEnabledTypeTag(t *types.Type) *enabledTagValue {
	comments := append(append([]string{}, t.SecondClosestCommentLines...), t.CommentLines...)
	return extractEnabledTag(comments)
}

func extractEnabledTag(comments []string) *enabledTagValue {
	_, ok := gengo.ExtractCommentTags("+", comments)[tagEnabledName]
	if !ok {
		// No match for the tag.
		return nil
	}
	// If there are multiple values, abort.

	// If we got here we are returning something.
	tag := &enabledTagValue{value: "true"}
	tag.register = true
	return tag
}

func GetTargets(context *generator.Context, args *args.Args) []generator.Target {
	boilerplate, err := gengo.GoBoilerplate(args.GoHeaderFile, IgnoreTag, gengo.StdGeneratedBy)
	if err != nil {
		klog.Fatalf("Failed loading boilerplate: %v", err)
	}

	targets := []generator.Target{}

	for _, i := range context.Inputs {
		klog.V(3).Infof("Considering pkg %q", i)

		pkg := context.Universe[i]
		pkgNeedsGeneration := false
		for _, t := range pkg.Types {
			klog.V(3).Infof("  considering type %q", t.Name.String())
			ttag := extractEnabledTypeTag(t)
			if ttag != nil && ttag.value == "true" {
				klog.V(3).Infof("    tag found")
				pkgNeedsGeneration = true
			}
		}
		if pkgNeedsGeneration {
			klog.V(3).Infof("Package %q needs generation", i)
			targets = append(
				targets,
				&generator.SimpleTarget{
					PkgName:       strings.Split(path.Base(pkg.Path), ".")[0],
					PkgPath:       pkg.Path,
					PkgDir:        pkg.Dir, // output pkg is the same as the input
					HeaderComment: boilerplate,
					FilterFunc: func(c *generator.Context, t *types.Type) bool {
						return t.Name.Package == pkg.Path
					},
					GeneratorsFunc: func(c *generator.Context) (generators []generator.Generator) {
						return []generator.Generator{
							NewGenKeepAlive(args.OutputFile, pkg.Path, args.UsePool, args.UseMongo),
						}
					},
				},
			)
		}
	}
	return targets
}

func NewGenKeepAlive(outputFilename, targetPackage string, usePool bool, useMongo bool) generator.Generator {
	dc := &genKeepAlive{
		GoGenerator: generator.GoGenerator{
			OutputFilename: outputFilename,
		},
		targetPackage: targetPackage,
		usePool:       usePool,
		useMongo:      useMongo,
	}
	typesToAdd := []*types.Type{
		{Name: types.Name{Package: "github.com/ravinggo/tools/keepalive-gen/keepalive"}},
		{Name: types.Name{Package: "unsafe"}},
	}
	if useMongo {
		typesToAdd = append(typesToAdd, &types.Type{Name: types.Name{Package: "go.mongodb.org/mongo-driver/v2/bson"}})
	}
	dc.imports = generator.NewImportTrackerForPackage(
		targetPackage,
		typesToAdd...,
	)

	return dc
}

func (g *genKeepAlive) Imports(c *generator.Context) (imports []string) {
	importLines := []string{}
	for _, singleImport := range g.imports.ImportLines() {
		if g.isOtherPackage(singleImport) {
			importLines = append(importLines, singleImport)
		}
	}
	return importLines
}
func (g *genKeepAlive) isOtherPackage(pkg string) bool {
	if pkg == g.targetPackage {
		return false
	}
	if strings.HasSuffix(pkg, "\""+g.targetPackage+"\"") {
		return false
	}
	return true
}

func (g *genKeepAlive) Namers(c *generator.Context) namer.NameSystems {
	// Have the raw namer for this file track what it imports.
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.targetPackage, g.imports),
		// "rawElem": namer.NewRawNamer(g.targetPackage, g.imports),
	}
}

// IsPrivateGoName Returns whether a name is a private Go name.
func IsPrivateGoName(name string) bool {
	return len(name) == 0 || strings.ToLower(name[:1]) == name[:1]
}

func underlyingType(t *types.Type) *types.Type {
	for t.Kind == types.Alias {
		t = t.Underlying
	}
	return t
}

func (g *genKeepAlive) Filter(c *generator.Context, t *types.Type) bool {
	// Filter out types not being processed or not copyable within the package.
	enabled := false
	ttag := extractEnabledTypeTag(t)
	if ttag != nil && ttag.value == "true" {
		enabled = true
	}
	if !enabled {
		return false
	}
	if t.Kind != types.Struct {
		return false
	}

	klog.V(3).Infof("Type %v is keepalive", t)
	return true
}

func deepCopyMethod(t *types.Type) (*types.Signature, error) {
	f, found := t.Methods["DeepCopy"]
	if !found {
		return nil, nil
	}
	if len(f.Signature.Parameters) != 0 {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected no parameters", t)
	}
	if len(f.Signature.Results) != 1 {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected exactly one result", t)
	}

	ptrResult := f.Signature.Results[0].Type.Kind == types.Pointer && f.Signature.Results[0].Type.Elem.Name == t.Name
	nonPtrResult := f.Signature.Results[0].Type.Name == t.Name

	if !ptrResult && !nonPtrResult {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected to return %s or *%s", t, t.Name.Name, t.Name.Name)
	}

	ptrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Kind == types.Pointer && f.Signature.Receiver.Elem.Name == t.Name
	nonPtrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Name == t.Name

	if ptrRcvr && !ptrResult {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected a *%s result for a *%s receiver", t, t.Name.Name, t.Name.Name)
	}
	if nonPtrRcvr && !nonPtrResult {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected a %s result for a %s receiver", t, t.Name.Name, t.Name.Name)
	}

	return f.Signature, nil
}

// deepCopyMethodOrDie returns the signatrue of a DeepCopy method, nil or calls klog.Fatalf
// if the type does not match.
func deepCopyMethodOrDie(t *types.Type) *types.Signature {
	ret, err := deepCopyMethod(t)
	if err != nil {
		klog.Fatal(err)
	}
	return ret
}

// deepCopyIntoMethod returns the signature of a DeepCopyInto() method, nil or an error
// if the type is wrong. DeepCopyInto allows more efficient deep copy
// implementations to be defined by the type's author.  The correct signature
// for a type T is:
//
//	func (t T) DeepCopyInto(t *T)
//
// or:
//
//	func (t *T) DeepCopyInto(t *T)
func deepCopyIntoMethod(t *types.Type) (*types.Signature, error) {
	f, found := t.Methods["DeepCopyInto"]
	if !found {
		return nil, nil
	}
	if len(f.Signature.Parameters) != 1 {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected exactly one parameter", t)
	}
	if len(f.Signature.Results) != 0 {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected no result type", t)
	}

	ptrParam := f.Signature.Parameters[0].Type.Kind == types.Pointer && f.Signature.Parameters[0].Type.Elem.Name == t.Name

	if !ptrParam {
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected parameter of type *%s", t, t.Name.Name)
	}

	ptrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Kind == types.Pointer && f.Signature.Receiver.Elem.Name == t.Name
	nonPtrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Name == t.Name

	if !ptrRcvr && !nonPtrRcvr {
		// this should never happen
		return nil, fmt.Errorf("type %v: invalid DeepCopy signature, expected a receiver of type %s or *%s", t, t.Name.Name, t.Name.Name)
	}

	return f.Signature, nil
}

func resetMethod(t *types.Type) (*types.Signature, error) {
	f, found := t.Methods["Reset"]
	if !found {
		return nil, nil
	}
	if len(f.Signature.Parameters) != 0 {
		return nil, fmt.Errorf("type %v: invalid Reset signature, expected exactly no parameter", t)
	}
	if len(f.Signature.Results) != 0 {
		return nil, fmt.Errorf("type %v: invalid Reset signature, expected no result type", t)
	}
	ptrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Kind == types.Pointer && f.Signature.Receiver.Elem.Name == t.Name
	nonPtrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Name == t.Name

	if !ptrRcvr && !nonPtrRcvr {
		// this should never happen
		return nil, fmt.Errorf("type %v: invalid Reset signature, expected a receiver of type %s or *%s", t, t.Name.Name, t.Name.Name)
	}
	return f.Signature, nil
}

func resetNoSelfMethod(t *types.Type) (*types.Signature, error) {
	f, found := t.Methods["ResetNoSelf"]
	if !found {
		return nil, nil
	}
	if len(f.Signature.Parameters) != 0 {
		return nil, fmt.Errorf("type %v: invalid ResetNoSelf signature, expected exactly no parameter", t)
	}
	if len(f.Signature.Results) != 0 {
		return nil, fmt.Errorf("type %v: invalid ResetNoSelf signature, expected no result type", t)
	}
	ptrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Kind == types.Pointer && f.Signature.Receiver.Elem.Name == t.Name
	nonPtrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Name == t.Name

	if !ptrRcvr && !nonPtrRcvr {
		// this should never happen
		return nil, fmt.Errorf("type %v: invalid ResetNoSelf signature, expected a receiver of type %s or *%s", t, t.Name.Name, t.Name.Name)
	}
	return f.Signature, nil
}

func resetNoSelfMethodOrDie(t *types.Type) *types.Signature {
	ret, err := resetNoSelfMethod(t)
	if err != nil {
		klog.Fatal(err)
	}
	return ret
}

func resetOnlySelfMethod(t *types.Type) (*types.Signature, error) {
	f, found := t.Methods["ResetOnlySelf"]
	if !found {
		return nil, nil
	}
	if len(f.Signature.Parameters) != 0 {
		return nil, fmt.Errorf("type %v: invalid ResetOnlySelf signature, expected exactly no parameter", t)
	}
	if len(f.Signature.Results) != 0 {
		return nil, fmt.Errorf("type %v: invalid ResetOnlySelf signature, expected no result type", t)
	}
	ptrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Kind == types.Pointer && f.Signature.Receiver.Elem.Name == t.Name
	nonPtrRcvr := f.Signature.Receiver != nil && f.Signature.Receiver.Name == t.Name

	if !ptrRcvr && !nonPtrRcvr {
		// this should never happen
		return nil, fmt.Errorf("type %v: invalid ResetOnlySelf signature, expected a receiver of type %s or *%s", t, t.Name.Name, t.Name.Name)
	}
	return f.Signature, nil
}

func resetOnlySelfMethodOrDie(t *types.Type) *types.Signature {
	ret, err := resetOnlySelfMethod(t)
	if err != nil {
		klog.Fatal(err)
	}
	return ret
}

func resetMethodOrDie(t *types.Type) *types.Signature {
	ret, err := resetMethod(t)
	if err != nil {
		klog.Fatal(err)
	}
	return ret
}

// deepCopyIntoMethodOrDie returns the signature of a DeepCopyInto() method, nil or calls klog.Fatalf
// if the type is wrong.
func deepCopyIntoMethodOrDie(t *types.Type) *types.Signature {
	ret, err := deepCopyIntoMethod(t)
	if err != nil {
		klog.Fatal(err)
	}
	return ret
}

func argsFromType(parent string, ts ...*types.Type) generator.Args {
	a := generator.Args{
		"parent": parent,
		"type":   ts[0],
	}

	return a
}

type (
	structOrSlice struct {
		structType     map[*types.Member]int
		sliceOrMapType map[*types.Member]int
		sw             *generator.SnippetWriter
		parentName     string
	}
)

func getIDName(t *types.Type) string {
	if t.Kind != types.Struct {
		return ""
	}
	for _, v := range t.Members {
		if strings.Contains(v.Tags, "key_id") {
			return v.Name
		}
	}
	return ""
}

func getIDType(t *types.Type) *types.Type {
	if t.Kind != types.Struct {
		return nil
	}
	for _, v := range t.Members {
		if strings.Contains(v.Tags, "key_id") {
			if v.Type.Kind != types.Builtin && v.Type.String() != objectIDName {
				klog.Fatalf("getIDType(%s) key_id type(%s) is not Builtin", t.Name.String(), v.Type.String())
			}
			return v.Type
		}
	}
	return nil
}

func (g *genKeepAlive) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
	if extractEnabledTypeTag(t) == nil {
		return nil
	}

	klog.V(2).Infof("Generating keepalive functions for type %v", t)
	ss := &structOrSlice{
		structType:     map[*types.Member]int{},
		sliceOrMapType: map[*types.Member]int{},
		sw:             generator.NewSnippetWriter(w, c, "$", "$"),
		parentName:     t.Name.Name,
	}

	for i, m := range t.Members {
		if !IsPrivateGoName(m.Name) {
			continue
		}
		var elem *types.Type
		switch m.Type.Kind {
		case types.Slice:
			elem = underlyingType(m.Type.Elem)
			switch elem.Kind {
			case types.Pointer:
				klog.Warningf("field '%s %s' is a pointer of a slice,recommend using value type\n", m.Name, m.Type.Name.Name)
			case types.Struct:
			case types.Builtin:
			default:
				klog.Fatalf("field:'%s' slice not supported type:%s\n", m.Name, elem.Kind)
			}
		case types.Struct:
			elem = underlyingType(m.Type)
		case types.Map:
			keyType := underlyingType(m.Type.Key)
			if keyType.Kind != types.Builtin {
				klog.Fatalf("field:'%s' map not supported key type:%s\n", m.Name, m.Type.Name.Name)
			}
			elem = underlyingType(m.Type.Elem)
			switch elem.Kind {
			case types.Pointer:
				if len(elem.Elem.Members) > 8 {
					klog.Warningf("field '%s %s' is a pointer to a map,recommend using value type\n", m.Name, m.Type.Name.Name)
				}
			case types.Struct:
			default:
				klog.Fatalf("field:'%s' map not supported type:%s\n", m.Name, m.Type.Name.Name)
			}
		default:
			klog.Fatalf("field:'%s' not supported type:%s\n", m.Name, m.Type.Name.Name)
		}
		if elem == nil {
			continue
		}
		switch elem.Kind {
		case types.Builtin:
			continue
		case types.Pointer:
			elem = underlyingType(elem.Elem)
		}
		if deepCopyMethodOrDie(elem) == nil {
			klog.Fatalf("DeepCopy method not found for type %s\n", elem.Name.String())
		}

		if deepCopyIntoMethodOrDie(elem) == nil {
			klog.Fatalf("DeepCopyInto method not found for type %s\n", elem.Name.String())
		}
		if g.usePool {
			if resetMethodOrDie(elem) == nil {
				klog.Fatalf("Reset method not found for type %s\n", elem.Name.String())
			}

			if resetNoSelfMethodOrDie(elem) == nil {
				klog.Fatalf("ResetNoSelf method not found for type %s\n", elem.Name.String())
			}

			if resetOnlySelfMethodOrDie(elem) == nil {
				klog.Fatalf("ResetOnlySelf method not found for type %s\n", elem.Name.String())
			}
		}
		g.genOneField(ss, &t.Members[i])
	}
	g.genFunc(ss)
	g.genDB(ss)
	return ss.sw.Error()
}

func (g *genKeepAlive) genOneField(ss *structOrSlice, t *types.Member) {
	switch t.Type.Kind {
	case types.Slice:
		ss.sliceOrMapType[t]++
		if t.Type.Elem.Kind == types.Pointer {
			g.genSlicePtrElem(ss, t)
		} else if t.Type.Elem.Kind == types.Struct {
			if t.Type.Elem.IsAssignable() {
				g.genSlice(ss, t)
			} else {
				g.genSlicePtrElem(ss, t)
			}
		}
	case types.Map:
		ss.sliceOrMapType[t]++
		if t.Type.Elem.Kind == types.Pointer {
			g.genMapPtrElem(ss, t)
		} else if t.Type.Elem.Kind == types.Struct {
			if t.Type.Elem.IsAssignable() {
				g.genMap(ss, t)
			} else {
				g.genMapPtrElem(ss, t)
			}
		}
	case types.Struct:
		ss.structType[t]++
		g.genStruct(ss, t)
	default:
		klog.Fatalf("field:'%s' not supported type:%s\n", t.Name, t.Type.String())
	}
}

func (g *genKeepAlive) genStruct(ss *structOrSlice, t *types.Member) {
	args := generator.Args{
		"parent": ss.parentName,
		"type":   t.Type,
		"name":   t.Name,
	}
	sw := ss.sw
	// /////////////////////////////////////////////////////
	sw.Do(
		`
	func (d *$.parent$) Get$.type|raw$ReadOnly() *$.type|raw$ {
	index := d.$.type|raw$KAIndex()
	i := d.DUsed[index]
	var e *keepalive.KAElem
	if i == -1 {
		e, i = d.AddData()
		d.DUsed[index] = i
	} else {
		e = &d.Data[i]
	}
	if e.State > keepalive.KAStateDelete {
		return (*$.type|raw$)(e.Data)
	}
	return &d.$.name$
}
`, args,
	)
	// ////////////////////////////////////////////////////
	sw.Do("func (d *$.parent$) Get$.type|raw$() *$.type|raw${\n", args)
	sw.Do("index := d.$.type|raw$KAIndex()\n", args)
	sw.Do("i := d.DUsed[index]\n", args)
	sw.Do("var e *keepalive.KAElem\n", args)
	sw.Do(
		`if i == -1 {
				e, i = d.AddData()
				d.DUsed[index] = i
			} else {
				e = &d.Data[i]
			}
`, args,
	)
	sw.Do(
		`if e.State > keepalive.KAStateDelete {
				return (*$.type|raw$)(e.Data)
			}
`, args,
	)
	sw.Do("x := d.$.name$.DeepCopy()\n", args)
	sw.Do(
		`e.Data = unsafe.Pointer(x)
			e.State = keepalive.KAStateRead
			
			return x
`, args,
	)
	sw.Do("}\n", args)
	// ////////////////////////////////////////////////////
	sw.Do("func (d *$.parent$) Save$.type|raw$(){\n", args)
	sw.Do("index := d.$.type|raw$KAIndex()\n", args)
	sw.Do("i := d.DUsed[index]\n", args)
	sw.Do("var e *keepalive.KAElem\n", args)
	sw.Do(
		`if i == -1 {
				e, i = d.AddData()
				d.DUsed[index] = i
			} else {
				e = &d.Data[i]
			}
`, args,
	)
	sw.Do(
		`
	if e.State == keepalive.KAStateReset {
		panic("no Get,but Save")
	}
	e.State = keepalive.KAStateSave
	if e.Wrote == 0 {
		e.Wrote = 1
		e.WriteIndex = index
		d.WI = append(d.WI, index)
	}
`, args,
	)
	sw.Do("}\n", args)

	// ////////////////////////////////////////////////////
	if g.usePool {
		sw.Do(
			`
func Swap$.parent$$.type|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.type|raw$)(p)
	d.$.name$.ResetNoSelf()
	d.$.name$ = *u
	u.ResetOnlySelf()
}
`, args,
		)
	} else {
		sw.Do(
			`
func Swap$.parent$$.type|raw$(d *$.parent$, p unsafe.Pointer) {
	d.$.name$ = *(*$.type|raw$)(p)
}
`, args,
		)
	}
}

func (g *genKeepAlive) genSlice(ss *structOrSlice, t *types.Member) {
	elem := t.Type.Elem
	for elem.Kind == types.Pointer {
		elem = elem.Elem
	}
	_id := getIDName(elem)
	_idType := getIDType(elem)
	args := generator.Args{
		"parent": ss.parentName,
		"type":   t.Type,
		"name":   t.Name,
		"elem":   elem,
		"id":     _id,
		"idtyp":  _idType,
	}
	sw := ss.sw
	sw.Do(
		`
	func (d *$.parent$) Get$.elem|raw$(id $.idtyp|raw$) ($.elem|raw$, bool) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if state != 0 {
		return *v, state == 1
	}
		
	for _,v:=range d.$.name${
		if v.$.id$ == id{
			return v,true
		}
	}

	return $.elem|raw${},false
}
`, args,
	)
	sw.Do(
		`
func (d *$.parent$)Range$.elem|raw$s(f func(v *$.elem|raw$) bool)  {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for i := range d.$.name$ {
			if !f(&d.$.name$[i]){
				break
			}
		}
	}else{
		m:=make(map[$.idtyp|raw$]*keepalive.KAElem,len(*kas))
		for i,v:=range *kas{
			if v.NoOrigin!=0{
				if v.State == keepalive.KAStateSave{
					temp := (*$.elem|raw$)(v.Data)
					if !f(temp) {
						return
					}
				}else if v.State==keepalive.KAStateDelete{
					continue
				}
			}
			item:=(*$.elem|raw$)(v.Data)
			m[item.$.id$]=&(*kas)[i]
		}
		for i := range d.$.name$ {
			v:= &d.$.name$[i]
			if newV,ok:=m[v.$.id$];ok{
				if newV.State!=keepalive.KAStateDelete{
					if !f((*$.elem|raw$)(newV.Data)){
						break
					}
				}
			}else{
				if !f(v){
					break
				}
			}
		}
	}
}
`, args,
	)
	sw.Do(
		`
	func (d *$.parent$) Save$.elem|raw$(save $.elem|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := save.$.id$
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		return
	}
	noOrigin :=int32(1)
	for _, v := range d.$.name$ {
		if v.$.id$ == id {
			noOrigin = 0
			break
		}
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(save.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}
`, args,
	)

	sw.Do(
		`
	
func (d *$.parent$) Delete$.elem|raw$(id $.idtyp|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.WriteIndex == 0 {
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
			e.Wrote = 1
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := keepalive.SliceFind(
		d.$.name$, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)

	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}
`, args,
	)
	sw.Do(
		`
func (d *$.parent$) Len$.elem|raw$() int {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count:=len(d.$.name$)
	if len(*kas)>0{
		for _, v := range *kas {
			 if v.State == keepalive.KAStateSave&&v.NoOrigin!=0{
				count++
			}else if v.State == keepalive.KAStateDelete && v.NoOrigin==0{
				count--
			}
		}
	}
	return count
}
`, args,
	)
	if g.usePool {
		sw.Do(
			`
func Swap$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	old, ok := keepalive.SliceFind(
		d.$.name$, func(v *$.elem|raw$) bool {
			return v.$.id$ == newV.$.id$
		},
	)
	if ok {
		*old = *newV
	} else {
		d.$.name$ = append(d.$.name$, *newV)
	}
	newV.Reset()
}

func Delete$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	newSV, ok := keepalive.SwapDelete(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if ok {
		d.$.name$ = newSV
	}
	newV.Reset()
}
`, args,
		)
	} else {
		sw.Do(
			`
func Swap$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	old, ok := keepalive.SliceFind(
		d.$.name$, func(v *$.elem|raw$) bool {
			return v.$.id$ == newV.$.id$
		},
	)
	if ok {
		*old = *newV
	} else {
		d.$.name$ = append(d.$.name$, *newV)
	}
}

func Delete$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	newSV, ok := keepalive.SwapDelete(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if ok {
		d.$.name$ = newSV
	}
}
`, args,
		)
	}
}

func (g *genKeepAlive) genSlicePtrElem(ss *structOrSlice, t *types.Member) {
	elem := t.Type.Elem
	isPtr := false
	ga := "&"
	for elem.Kind == types.Pointer {
		elem = elem.Elem
		isPtr = true
		ga = ""
	}
	_id := getIDName(elem)
	_idType := getIDType(elem)
	args := generator.Args{
		"parent": ss.parentName,
		"type":   t.Type,
		"name":   t.Name,
		"elem":   elem,
		"id":     _id,
		"idtyp":  _idType,
		"find":   "keepalive.SliceFind",
		"delete": "keepalive.SwapDelete",
		"ga":     ga,
	}
	if isPtr {
		args["find"] = "keepalive.SliceFindPtr"
		args["delete"] = "keepalive.SwapDeletePtr"
	}
	sw := ss.sw
	sw.Do(
		`
	func (d *$.parent$) Get$.elem|raw$(id $.idtyp|raw$) (*$.elem|raw$, bool) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if state != 0 {
		return v, state == 1
	}

	origin, ok := $.find$(
		d.$.name$, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if !ok {
		return nil, false
	}
	v = origin.DeepCopy()
	*kas = append(
		*kas, keepalive.KAElem{
			Data:  unsafe.Pointer(v),
			State: keepalive.KAStateRead,
		},
	)
	return v, true
}
`, args,
	)
	// ////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$)Range$.elem|raw$s(f func(v *$.elem|raw$) bool)  {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for i := range d.$.name$ {
			if !f($.ga$d.$.name$[i]){
				break
			}
		}
	}else{
		m:=make(map[$.idtyp|raw$]*keepalive.KAElem,len(*kas))
		for i,v:=range *kas{
			if v.NoOrigin!=0{
				if v.State == keepalive.KAStateSave{
					temp := (*$.elem|raw$)(v.Data)
					if !f(temp) {
						return
					}
				}else if v.State==keepalive.KAStateDelete{
					continue
				}
			}
			item:=(*$.elem|raw$)(v.Data)
			m[item.$.id$]=&(*kas)[i]
		}
		for i:= range d.$.name$ {
			v:=$.ga$d.$.name$[i]
			if newV,ok:=m[v.$.id$];ok{
				if newV.State!=keepalive.KAStateDelete{
					if !f((*$.elem|raw$)(newV.Data)){
						break
					}
				}
			}else{
				if !f(v){
					break
				}
			}
		}
	}
}
`, args,
	)
	// ////////////////////////////////////////////////////////////
	sw.Do(
		`
	func (d *$.parent$) Save$.elem|raw$(save *$.elem|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := save.$.id$
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State = keepalive.KAStateSave
		}
		return
	}
	noOrigin :=int32(1)
	for _, v := range d.$.name$ {
		if v.$.id$ == id {
			noOrigin = 0
			break
		}
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(save.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}
`, args,
	)
	sw.Do(
		`
func (d *$.parent$) Len$.elem|raw$() int {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count:=len(d.$.name$)
	if len(*kas)>0{
		for _, v := range *kas {
			 if v.State == keepalive.KAStateSave&&v.NoOrigin!=0{
				count++
			}else if v.State == keepalive.KAStateDelete && v.NoOrigin==0{
				count--
			}
		}
	}
	return count
}
`, args,
	)
	sw.Do(
		`
	
func (d *$.parent$) Delete$.elem|raw$(id $.idtyp|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.WriteIndex == 0 {
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
			e.Wrote = 1
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := $.find$(
		d.$.name$, func(v *$.elem|raw$) bool {
			return v.$.id$ == id
		},
	)

	if ok {
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}
`, args,
	)
	if g.usePool {
		if !isPtr {
			sw.Do(
				`
func Swap$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	old, ok := $.find$(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				v.ResetNoSelf()
				return true
			}
			return false
		},
	)
	if ok {
		*old = *newV
	} else {
		d.$.name$ = append(d.$.name$, *newV)
	}
	newV.ResetOnlySelf()
}

func Delete$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	newSV, ok := $.delete$(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				v.ResetNoSelf()
				return true
			}
			return false
		},
	)
	if ok {
		d.$.name$ = newSV
	}
	newV.Reset()
}
`, args,
			)
		} else {
			sw.Do(
				`
func Swap$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	index := keepalive.SliceFindIndex(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if index>0 {
		old:=d.$.name$[index]
		d.$.name$[index]=newV
		old.Reset()
	} else {
		d.$.name$ = append(d.$.name$, newV)
	}
}

func Delete$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	newSV, ok := $.delete$(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				v.Reset()
				return true
			}
			return false
		},
	)
	if ok {
		d.$.name$ = newSV
	}
	newV.Reset()
}
`, args,
			)
		}
	} else {
		if !isPtr {
			sw.Do(
				`
func Swap$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	old, ok := $.find$(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if ok {
		*old = *newV
	} else {
		d.$.name$ = append(d.$.name$, *newV)
	}
}

func Delete$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	newSV, ok := $.delete$(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if ok {
		d.$.name$ = newSV
	}
}
`, args,
			)
		} else {
			sw.Do(
				`
func Swap$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	index := keepalive.SliceFindIndex(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if index>0 {
		d.$.name$[index]=newV
	} else {
		d.$.name$ = append(d.$.name$, newV)
	}
}

func Delete$.parent$$.elem|raw$(d *$.parent$, pointer unsafe.Pointer) {
	newV := (*$.elem|raw$)(pointer)
	newSV, ok := $.delete$(
		d.$.name$, func(v *$.elem|raw$) bool {
			if v.$.id$ == newV.$.id$ {
				return true
			}
			return false
		},
	)
	if ok {
		d.$.name$ = newSV
	}
}
`, args,
			)
		}
	}
}

func (g *genKeepAlive) genMap(ss *structOrSlice, t *types.Member) {
	elem := t.Type.Elem
	for elem.Kind == types.Pointer {
		elem = elem.Elem
	}
	_id := getIDName(elem)
	args := generator.Args{
		"parent": ss.parentName,
		"type":   t.Type,
		"name":   t.Name,
		"elem":   elem,
		"key":    t.Type.Key,
		"id":     _id,
	}
	sw := ss.sw
	// ////////////////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$) Get$.elem|raw$(id $.key|raw$) ($.elem|raw$, bool) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(da *$.elem|raw$) bool {
			return da.$.id$ == id
		},
	)
	if state != 0 {
		return *v, state == 1
	}
	origin, ok := d.$.name$[id]
	return origin, ok
}
`, args,
	)
	// /////////////////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$)Range$.elem|raw$s(f func(k $.key|raw$,v $.elem|raw$) bool)  {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for k,v := range d.$.name$ {
			if !f(k,v){
				break
			}
		}
	}else{
		m:=make(map[$.key|raw$]*keepalive.KAElem,len(*kas))
		for i,v:=range *kas{
			if v.NoOrigin!=0{
				if v.State == keepalive.KAStateSave{
					temp := (*$.elem|raw$)(v.Data)
					if !f(temp.$.id$, *temp) {
						return
					}
				}else if v.State==keepalive.KAStateDelete{
					continue
				}
			}
			temp:=(*$.elem|raw$)(v.Data)
			m[temp.$.id$]=&(*kas)[i]
		}
		for k,v := range d.$.name$ {
			if newV,ok:=m[k];ok{
				if newV.State!=keepalive.KAStateDelete{
					if !f(k,*(*$.elem|raw$)(newV.Data)){
						break
					}
				}
			}else{
				if !f(k,v){
					break
				}
			}
		}
	}
}
`, args,
	)
	// ////////////////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$) Save$.elem|raw$(v $.elem|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := v.$.id$
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *$.elem|raw$) bool {
			return da.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State =keepalive.KAStateSave
		}
		*(*$.elem|raw$)(e.Data) = v
		return
	}
	var noOrigin int32
	if _ , ok =d.$.name$[id];!ok{
		noOrigin=1
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(v.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,   
			Wrote:      1,
		},
	)
}
`,
		args,
	)
	// ////////////////////////////////////////////////////

	sw.Do(
		`
func (d *$.parent$) Delete$.elem|raw$(id $.key|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *$.elem|raw$) bool {
			return da.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := d.$.name$[id]
	if ok{
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}
`, args,
	)
	sw.Do(
		`
func (d *$.parent$) Len$.elem|raw$() int {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count:=len(d.$.name$)
	if len(*kas)>0{
		for _, v := range *kas {
			 if v.State == keepalive.KAStateSave&&v.NoOrigin!=0{
				count++
			}else if v.State == keepalive.KAStateDelete && v.NoOrigin==0{
				count--
			}
		}
	}
	return count
}
`, args,
	)
	// /////////////////////////////////////
	if g.usePool {
		sw.Do(
			`
func Swap$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	old, ok := d.$.name$[u.$.id$]
	if ok {
		old.ResetNoSelf()
		d.$.name$[u.$.id$] = *u
	} else {
		d.$.name$[u.$.id$] = *u
	}
	u.ResetOnlySelf()
}

func Delete$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	old, ok := d.$.name$[u.$.id$]
	if ok {
		delete(d.$.name$, u.$.id$)
		old.ResetNoSelf()
	}
	u.Reset()
}
`,
			args,
		)
	} else {
		sw.Do(
			`
func Swap$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u:=*(*Item)(p)
	d.$.name$[u.$.id$] = u
}

func Delete$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	delete(d.$.name$, u.$.id$)
}
`,
			args,
		)

	}
}

func (g *genKeepAlive) genMapPtrElem(ss *structOrSlice, t *types.Member) {
	elem := t.Type.Elem
	for elem.Kind == types.Pointer {
		elem = elem.Elem
	}
	_id := getIDName(elem)
	args := generator.Args{
		"parent": ss.parentName,
		"type":   t.Type,
		"name":   t.Name,
		"elem":   elem,
		"key":    t.Type.Key,
		"id":     _id,
	}
	sw := ss.sw
	// ////////////////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$) Get$.elem|raw$(id $.key|raw$) (*$.elem|raw$, bool) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	v, state := keepalive.SliceFindKA(
		*kas, func(da *$.elem|raw$) bool {
			return da.$.id$ == id
		},
	)
	if state != 0 {
		return v, state == 1
	}
	origin, ok := d.$.name$[id]
	if !ok {
		return nil, false
	}
	v = origin.DeepCopy()
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(v),
			State:      keepalive.KAStateRead,
		},
	)
	return v, ok
}
`, args,
	)
	// /////////////////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$)Range$.elem|raw$s(f func(k $.key|raw$,v *$.elem|raw$) bool)  {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	if len(*kas) == 0 {
		for k,v := range d.$.name$ {
			if !f(k,v){
				break
			}
		}
	}else{
		m:=make(map[$.key|raw$]*keepalive.KAElem,len(*kas))
		for i,v:=range *kas{
			if v.NoOrigin!=0{
				if v.State == keepalive.KAStateSave{
					temp := (*$.elem|raw$)(v.Data)
					if !f(temp.$.id$, temp) {
						return
					}
				}else if v.State==keepalive.KAStateDelete{
					continue
				}
			}
			item:=(*$.elem|raw$)(v.Data)
			m[item.$.id$]=&(*kas)[i]
		}
		for k,v := range d.$.name$ {
			if newV,ok:=m[k];ok{
				if newV.State!=keepalive.KAStateDelete{
					if !f(k,(*$.elem|raw$)(newV.Data)){
						break
					}
				}
			}else{
				if !f(k,v){
					break
				}
			}
		}
	}
}
`, args,
	)
	// ////////////////////////////////////////////////////
	sw.Do(
		`
func (d *$.parent$) Save$.elem|raw$(v *$.elem|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	id := v.$.id$
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *$.elem|raw$) bool {
			return da.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateSave
		} else if e.State != keepalive.KAStateSave {
			e.State =keepalive.KAStateSave
		}
		e.Data = unsafe.Pointer(v)
		return
	}
	var noOrigin int32
	if _ , ok =d.$.name$[id];!ok{
		noOrigin=1
	}
	d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
	*kas = append(
		*kas, keepalive.KAElem{
			Data:       unsafe.Pointer(v.DeepCopy()),
			State:      keepalive.KAStateSave,
			WriteIndex: index,
			NoOrigin:   noOrigin,
			Wrote:      1,
		},
	)
}
`,
		args,
	)
	// ////////////////////////////////////////////////////

	sw.Do(
		`
func (d *$.parent$) Delete$.elem|raw$(id $.key|raw$) {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	ei, ok := keepalive.SliceFindKAForSave(
		*kas, func(da *$.elem|raw$) bool {
			return da.$.id$ == id
		},
	)
	if ok {
		e := &(*kas)[ei]
		if e.Wrote == 0 {
			e.Wrote = 1
			e.WriteIndex = index
			d.WSI = append(d.WSI, index<<32|int64(ei))
			e.State = keepalive.KAStateDelete
		} else if e.State != keepalive.KAStateDelete {
			e.State = keepalive.KAStateDelete
		}
		return
	}
	v, ok := d.$.name$[id]
	if ok{
		d.WSI = append(d.WSI, index<<32|int64(len(*kas)))
		*kas = append(
			*kas, keepalive.KAElem{
				Data:       unsafe.Pointer(v.DeepCopy()),
				State:      keepalive.KAStateDelete,
				WriteIndex: index,
				Wrote:      1,
			},
		)
	}
}
`, args,
	)
	sw.Do(
		`
func (d *$.parent$) Len$.elem|raw$() int {
	index := d.$.elem|raw$KAIndex()
	i := d.SDUsed[index]
	var kas *[]keepalive.KAElem
	if i == -1 {
		kas, i = d.AddSliceData()
		d.SDUsed[index] = i
	} else {
		kas = &d.SliceData[i]
	}
	count:=len(d.$.name$)
	if len(*kas)>0{
		for _, v := range *kas {
			 if v.State == keepalive.KAStateSave&&v.NoOrigin!=0{
				count++
			}else if v.State == keepalive.KAStateDelete && v.NoOrigin==0{
				count--
			}
		}
	}
	return count
}
`, args,
	)
	// /////////////////////////////////////
	if g.usePool {
		sw.Do(
			`
func Swap$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	old, ok := d.$.name$[u.$.id$]
	if ok {
		d.$.name$[u.$.id$] = u
		old.Reset()
	} else {
		d.$.name$[u.$.id$] = u
	}
}

func Delete$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	old, ok := d.$.name$[u.$.id$]
	if ok {
		delete(d.$.name$, u.$.id$)
		old.Reset()
	}
}
`,
			args,
		)
	} else {
		sw.Do(
			`
func Swap$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	d.$.name$[u.$.id$] = u
}

func Delete$.parent$$.elem|raw$(d *$.parent$, p unsafe.Pointer) {
	u := (*$.elem|raw$)(p)
	delete(d.$.name$, u.$.id$)
}
`,
			args,
		)
	}
}

func (g *genKeepAlive) genFunc(ss *structOrSlice) {
	sw := ss.sw
	names := make([]*types.Member, 0, len(ss.structType))
	for t := range ss.structType {
		names = append(names, t)
	}
	sort.Slice(
		names, func(i, j int) bool {
			return names[i].Name < names[j].Name
		},
	)
	typLen := len(names)
	for i, t := range names {
		args := generator.Args{
			"parent": ss.parentName,
			"type":   t.Type,
			"name":   t.Name,
		}
		sw.Do("func (d *$.parent$) $.type|raw$KAIndex() int64{\n", args)
		sw.Do(fmt.Sprintf("return %d\n", i), args)
		sw.Do("}\n", args)
	}
	sw.Do("var Save$.$FuncSlice = [...]func(*$.$, unsafe.Pointer){\n", ss.parentName)
	for i, t := range names {
		args := generator.Args{
			"parent": ss.parentName,
			"type":   t.Type,
			"name":   t.Name,
			"index":  i,
		}
		sw.Do("$.index$:Swap$.parent$$.type|raw$,\n", args)
	}
	sw.Do("}\n", nil)
	if g.usePool {
		sw.Do("var Reset$.$FuncSlice = [...]func(unsafe.Pointer){\n", ss.parentName)
		for i, t := range names {
			args := generator.Args{
				"type":  t.Type,
				"index": i,
			}
			sw.Do(
				`$.index$: func( pointer unsafe.Pointer) {
				(*$.type|raw$)(pointer).Reset()
			},
`, args,
			)
		}
		sw.Do("}\n", nil)
	}
	/*
		var ResetUserDataFuncSlice = [...]func( unsafe.Pointer){
			0: func( pointer unsafe.Pointer) {
				(*User)(pointer).Reset()
			},
		}
	*/
	sw.Do("var indexType$.$ = [...]int{\n", ss.parentName)
	for range typLen {
		sw.Do("-1,", nil)
	}
	sw.Do("\n}\n", nil)

	names = names[:0]
	for t := range ss.sliceOrMapType {
		names = append(names, t)
	}
	sort.Slice(
		names, func(i, j int) bool {
			return names[i].Name < names[j].Name
		},
	)
	typLen = len(names)
	for i, t := range names {
		typ := t.Type.Elem
		for typ.Kind == types.Pointer {
			typ = typ.Elem
		}
		args := generator.Args{
			"parent": ss.parentName,
			"type":   typ,
			"name":   t.Name,
		}
		sw.Do("func (d *$.parent$) $.type|raw$KAIndex() int64{\n", args)
		sw.Do(fmt.Sprintf("return %d\n", i), args)
		sw.Do("}\n", args)
	}

	sw.Do("var SaveSlice$.$FuncSlice = [...]func(*$.$, unsafe.Pointer){\n", ss.parentName)
	for i, t := range names {
		typ := t.Type.Elem
		for typ.Kind == types.Pointer {
			typ = typ.Elem
		}
		args := generator.Args{
			"parent": ss.parentName,
			"type":   typ,
			"name":   t.Name,
			"index":  i,
		}
		sw.Do("$.index$:Swap$.parent$$.type|raw$,\n", args)
	}
	sw.Do("}\n", nil)

	sw.Do("var DeleteSlice$.$FuncSlice = [...]func(*$.$, unsafe.Pointer){\n", ss.parentName)
	for i, t := range names {
		typ := t.Type.Elem
		for typ.Kind == types.Pointer {
			typ = typ.Elem
		}
		args := generator.Args{
			"parent": ss.parentName,
			"type":   typ,
			"name":   t.Name,
			"index":  i,
		}
		sw.Do("$.index$:Delete$.parent$$.type|raw$,\n", args)
	}
	sw.Do("}\n", nil)
	if g.usePool {
		sw.Do("var ResetSlice$.$FuncSlice = [...]func(unsafe.Pointer){\n", ss.parentName)
		for i, t := range names {
			typ := t.Type.Elem
			for typ.Kind == types.Pointer {
				typ = typ.Elem
			}
			args := generator.Args{
				"type":  typ,
				"index": i,
			}
			sw.Do(
				`$.index$: func( pointer unsafe.Pointer) {
				(*$.type|raw$)(pointer).Reset()
			},
`, args,
			)
		}
		sw.Do("}\n", nil)
	}
	sw.Do(
		`
func (d *$.$)Init(){
	if d.DUsed == nil {
		d.DUsed = make([]int, len(indexType$.$))
	}
	if d.SDUsed == nil {
		d.SDUsed = make([]int, len(indexSliceType$.$))
	}
`, ss.parentName,
	)
	sw.Do("d.ClearKeepalive()\n", nil)
	for i, t := range names {
		typ := t.Type.Elem
		args := generator.Args{
			"parent": ss.parentName,
			"type":   typ,
			"name":   t.Name,
			"index":  i,
			"key":    t.Type.Key,
		}
		if t.Type.Kind == types.Map {
			sw.Do("d.$.name$=make(map[$.key|raw$]$.type|raw$,16)\n", args)
		} else if t.Type.Kind == types.Slice {
			sw.Do("d.$.name$=make([]$.type|raw$,0,16)\n", args)
		}
	}
	sw.Do("}\n", nil)

	sw.Do("var indexSliceType$.$ = [...]int{\n", ss.parentName)
	for range typLen {
		sw.Do("-1,", nil)
	}
	sw.Do("\n}\n", nil)

	sw.Do("func (d *$.$)ClearKeepalive(){\n", ss.parentName)
	sw.Do("d.KeepAlive.Clear(indexSliceType$.$[:], indexType$.$[:])", ss.parentName)
	sw.Do("}\n", nil)
	if g.usePool {
		sw.Do(
			`
func (d *$.$) Commit() {
	for _, e := range d.Data {
		if e.State == keepalive.KAStateSave {
			SaveUserDataFuncSlice[e.WriteIndex](d, e.Data)
		} else {
			ResetUserDataFuncSlice[e.WriteIndex](e.Data)
		}
	}

	for _, es := range d.SliceData {
		for _, e := range es {
			if e.State == keepalive.KAStateSave {
				SaveSliceUserDataFuncSlice[e.WriteIndex](d, e.Data)
			} else if e.State == keepalive.KAStateDelete {
				DeleteSliceUserDataFuncSlice[e.WriteIndex](d, e.Data)
			} else {
				ResetSliceUserDataFuncSlice[e.WriteIndex](e.Data)
			}
		}
	}
	d.ClearKeepalive()
}

func (d *$.$) Rollback() {
	for _, e := range d.Data {
		ResetUserDataFuncSlice[e.WriteIndex](e.Data)
	}

	for _, es := range d.SliceData {
		for _, e := range es {
			ResetSliceUserDataFuncSlice[e.WriteIndex](e.Data)
		}
	}
	d.ClearKeepalive()
}
`, ss.parentName,
		)
	} else {
		sw.Do(
			`
func (d *$.$) Commit() {
	for _, e := range d.Data {
		if e.State == keepalive.KAStateSave {
			SaveUserDataFuncSlice[e.WriteIndex](d, e.Data)
		} 
	}

	for _, es := range d.SliceData {
		for _, e := range es {
			if e.State == keepalive.KAStateSave {
				SaveSliceUserDataFuncSlice[e.WriteIndex](d, e.Data)
			} else if e.State == keepalive.KAStateDelete {
				DeleteSliceUserDataFuncSlice[e.WriteIndex](d, e.Data)
			}
		}
	}
	d.ClearKeepalive()
}

func (d *$.$) Rollback() {
	d.ClearKeepalive()
}
`, ss.parentName,
		)
	}
}

func (g *genKeepAlive) genDB(ss *structOrSlice) {
	sw := ss.sw
	names := make([]*types.Member, 0, len(ss.structType))
	for t := range ss.structType {
		names = append(names, t)
	}
	sort.Slice(
		names, func(i, j int) bool {
			return names[i].Name < names[j].Name
		},
	)
	sw.Do("type DB$.$Interface interface{\n", ss.parentName)
	for _, t := range names {
		sw.Do("Save$.|raw$(isNew bool,d *$.|raw$)error\n", t.Type)
	}

	names = names[:0]
	for t := range ss.sliceOrMapType {
		names = append(names, t)
	}
	sort.Slice(
		names, func(i, j int) bool {
			return names[i].Name < names[j].Name
		},
	)
	for _, t := range names {
		typ := t.Type.Elem
		for typ.Kind == types.Pointer {
			typ = typ.Elem
		}
		sw.Do("Save$.|raw$(isNew bool,d *$.|raw$)error\n", typ)
		sw.Do("Delete$.|raw$(d *$.|raw$)error\n", typ)
	}
	sw.Do("}\n", nil)

	// /////////////////////////////////////////////////
	sw.Do("var db$.$SliceFunc = [...]func(dbFace DB$.$Interface,e *keepalive.KAElem)error{", ss.parentName)
	for i, t := range names {
		typ := t.Type.Elem
		for typ.Kind == types.Pointer {
			typ = typ.Elem
		}
		sw.Do(
			`
	$.index$: func(dbFace DB$.parent$Interface, e *keepalive.KAElem)error {
		if e.State == keepalive.KAStateSave {
			return dbFace.Save$.type|raw$(e.NoOrigin!=0,(*$.type|raw$)(e.Data))
		}else if e.State == keepalive.KAStateDelete {
			return dbFace.Delete$.type|raw$((*$.type|raw$)(e.Data))
		}
		return nil
	},
`,
			generator.Args{
				"index":  i,
				"parent": ss.parentName,
				"type":   typ,
			},
		)
	}
	sw.Do("}\n", nil)
	if g.useMongo {
		sw.Do("var _ = bson.NilObjectID\n", nil)
		for _, t := range names {
			typ := t.Type.Elem
			for typ.Kind == types.Pointer {
				typ = typ.Elem
			}
			fieldName, fieldTypeName := getMongoPKTypeName(typ)
			args := generator.Args{"typ": typ, "tn": xstrings.ToSnakeCase(typ.Name.Name), "_id": fieldName, "_idType": fieldTypeName}
			sw.Do(
				`
func (*$.typ|raw$)TableName()string{
	return "$.tn$"
}
`, args,
			)
			sw.Do("func (v *$.typ|raw$)PK() $._idType|raw${", args)
			if fieldTypeName.String() == objectIDName {
				sw.Do("if v.$._id$ == bson.NilObjectID{v.$._id$ = bson.NewObjectID()}\n", args)
			} else {
				sw.Do("var zero $._idType|raw$\n", args)
				sw.Do(
					`if v.$._id$==zero{ panic ("PK() is zero value")}
`, args,
				)
			}
			sw.Do("return v.$._id$\n", args)
			sw.Do("}\n", nil)
		}
	}

	names = names[:0]
	for t := range ss.structType {
		names = append(names, t)
	}
	sort.Slice(
		names, func(i, j int) bool {
			return names[i].Name < names[j].Name
		},
	)

	sw.Do("var db$.$Func = [...]func(dbFace DB$.$Interface,e *keepalive.KAElem)error{", ss.parentName)
	for i, t := range names {
		sw.Do(
			`
	$.index$: func(dbFace DB$.parent$Interface, e *keepalive.KAElem)error {
		return dbFace.Save$.type|raw$(false,(*$.type|raw$)(e.Data))
	},
`,
			generator.Args{
				"index":  i,
				"parent": ss.parentName,
				"type":   t.Type,
			},
		)
	}
	sw.Do("}\n", nil)
	if g.useMongo {
		for _, t := range names {
			typ := t.Type
			fieldName, fieldTypeName := getMongoPKTypeName(typ)
			args := generator.Args{"typ": typ, "tn": xstrings.ToSnakeCase(typ.Name.Name), "_id": fieldName, "_idType": fieldTypeName}
			sw.Do(
				`
func (*$.typ|raw$)TableName()string{
	return "$.tn$"
}
`, args,
			)
			sw.Do("func (v *$.typ|raw$)PK() $._idType|raw${", args)
			if fieldTypeName.String() == objectIDName {
				sw.Do("if v.$._id$ == bson.NilObjectID{v.$._id$ = bson.NewObjectID()}\n", args)
			} else {
				sw.Do("var zero $._idType|raw$\n", args)
				sw.Do(
					`if v.$._id$==zero{ panic ("PK() is zero value")}
`, args,
				)
			}
			sw.Do("return v.$._id$\n", args)
			sw.Do("}\n", nil)
		}
	}
	sw.Do(
		`
func (d *$.$) DoDB(dbFace DB$.$Interface)error {
	for _,index:=range d.WI{
		e:=&d.Data[index]
		if err:=db$.$Func[index](dbFace,e);err!=nil{
			return err
		}
	}

	for _,index:=range d.WI{
		es:=d.SliceData[index]
		for i:=range es{
			e:=&es[i]
			if err:=db$.$SliceFunc[index](dbFace,e);err!=nil{
				return err
			}
		}
	}
	return nil
}
`,
		ss.parentName,
	)
}

func getMongoPKTypeName(t *types.Type) (string, *types.Type) {
	for _, v := range t.Members {
		if reflect.StructTag(v.Tags).Get("bson") == "_id" {
			return v.Name, v.Type
		}
	}
	panic(fmt.Sprintf(`%s not found tag bson:"_id"`, t.String()))
}
