//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by deepcopy-gen. DO NOT EDIT.

package maps

import (
	bits "math/bits"
	sync "sync"
	unsafe "unsafe"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Test2) DeepCopyInto(out *Test2) {
	*out = *in
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Test2.
func (in *Test2) DeepCopy() *Test2 {
	if in == nil {
		return nil
	}
	out := Test2Pool.Get().(*Test2)
	in.DeepCopyInto(out)
	return out
}

// Reset puts the given value back into the pool.
func (in *Test2) Reset() {
	if in == nil {
		return
	}
	*in = Test2{}
	Test2Pool.Put(in)
}

// ResetNoSelf puts the given field value back into the pool.
func (in *Test2) ResetNoSelf() {
	if in == nil {
		return
	}
}

// ResetOnlySelf puts the given value back into the pool.
func (in *Test2) ResetOnlySelf() {
	if in == nil {
		return
	}
	*in = Test2{}
	Test2Pool.Put(in)
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Ttest) DeepCopyInto(out *Ttest) {
	*out = *in
	if in.Byte != nil {
		in, out := &in.Byte, &out.Byte
		*out = map_string_byte_Pool.Get().(map[string]byte)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint8 != nil {
		in, out := &in.Uint8, &out.Uint8
		*out = map_string_uint8_Pool.Get().(map[string]uint8)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int8 != nil {
		in, out := &in.Int8, &out.Int8
		*out = map_string_int8_Pool.Get().(map[string]int8)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int16 != nil {
		in, out := &in.Int16, &out.Int16
		*out = map_string_int16_Pool.Get().(map[string]int16)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int32 != nil {
		in, out := &in.Int32, &out.Int32
		*out = map_string_int32_Pool.Get().(map[string]int32)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Int64 != nil {
		in, out := &in.Int64, &out.Int64
		*out = map_string_int64_Pool.Get().(map[string]int64)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint16 != nil {
		in, out := &in.Uint16, &out.Uint16
		*out = map_string_uint16_Pool.Get().(map[string]uint16)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint32 != nil {
		in, out := &in.Uint32, &out.Uint32
		*out = map_string_uint32_Pool.Get().(map[string]uint32)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Uint64 != nil {
		in, out := &in.Uint64, &out.Uint64
		*out = map_string_uint64_Pool.Get().(map[string]uint64)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Float32 != nil {
		in, out := &in.Float32, &out.Float32
		*out = map_string_float32_Pool.Get().(map[string]float32)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Float64 != nil {
		in, out := &in.Float64, &out.Float64
		*out = map_string_float64_Pool.Get().(map[string]float64)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.String != nil {
		in, out := &in.String, &out.String
		*out = map_string_string_Pool.Get().(map[string]string)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.StringPtr != nil {
		in, out := &in.StringPtr, &out.StringPtr
		*out = map_string_stringp__Pool.Get().(map[string]*string)
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = stringp_Pool.Get().(*string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.StringPtrPtr != nil {
		in, out := &in.StringPtrPtr, &out.StringPtrPtr
		*out = map_string_stringp_p__Pool.Get().(map[string]**string)
		for key, val := range *in {
			var outVal **string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = stringp_p_Pool.Get().(**string)
				if **in != nil {
					in, out := *in, *out
					*out = stringp_Pool.Get().(*string)
					**out = **in
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.Map != nil {
		in, out := &in.Map, &out.Map
		*out = map_string_map_string_string__Pool.Get().(map[string]map[string]string)
		for key, val := range *in {
			var outVal map[string]string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = map_string_string_Pool.Get().(map[string]string)
				for key, val := range *in {
					(*out)[key] = val
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.MapPtr != nil {
		in, out := &in.MapPtr, &out.MapPtr
		*out = map_string_map_string_string_p__Pool.Get().(map[string]*map[string]string)
		for key, val := range *in {
			var outVal *map[string]string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = map_string_string_p_Pool.Get().(*map[string]string)
				if **in != nil {
					in, out := *in, *out
					*out = map_string_string_Pool.Get().(map[string]string)
					for key, val := range *in {
						(*out)[key] = val
					}
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.Slice != nil {
		in, out := &in.Slice, &out.Slice
		*out = map_string_s_string_Pool.Get().(map[string][]string)
		for key, val := range *in {
			var outVal []string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = s_stringSPool.Get(len(*in))
				copy(*out, *in)
			}
			(*out)[key] = outVal
		}
	}
	if in.SlicePtr != nil {
		in, out := &in.SlicePtr, &out.SlicePtr
		*out = map_string_s_stringp__Pool.Get().(map[string]*[]string)
		for key, val := range *in {
			var outVal *[]string
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = s_stringp_Pool.Get().(*[]string)
				if **in != nil {
					in, out := *in, *out
					*out = s_stringSPool.Get(len(*in))
					copy(*out, *in)
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.Struct != nil {
		in, out := &in.Struct, &out.Struct
		*out = map_string_Ttest_Pool.Get().(map[string]Ttest)
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.StructPtr != nil {
		in, out := &in.StructPtr, &out.StructPtr
		*out = map_string_Ttestp__Pool.Get().(map[string]*Ttest)
		for key, val := range *in {
			var outVal *Ttest
			if val == nil {
				(*out)[key] = nil
			} else {
				in, out := &val, &outVal
				*out = Ttestp_Pool.Get().(*Ttest)
				(*in).DeepCopyInto(*out)
			}
			(*out)[key] = outVal
		}
	}
	if in.StructTest2 != nil {
		in, out := &in.StructTest2, &out.StructTest2
		*out = map_string_Test2_Pool.Get().(map[string]Test2)
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Ttest.
func (in *Ttest) DeepCopy() *Ttest {
	if in == nil {
		return nil
	}
	out := TtestPool.Get().(*Ttest)
	in.DeepCopyInto(out)
	return out
}

// Reset puts the given value back into the pool.
func (in *Ttest) Reset() {
	if in == nil {
		return
	}
	if in.Byte != nil {
		in := &in.Byte
		clear(*in)
		map_string_byte_Pool.Put(*in)
	}
	if in.Uint8 != nil {
		in := &in.Uint8
		clear(*in)
		map_string_uint8_Pool.Put(*in)
	}
	if in.Int8 != nil {
		in := &in.Int8
		clear(*in)
		map_string_int8_Pool.Put(*in)
	}
	if in.Int16 != nil {
		in := &in.Int16
		clear(*in)
		map_string_int16_Pool.Put(*in)
	}
	if in.Int32 != nil {
		in := &in.Int32
		clear(*in)
		map_string_int32_Pool.Put(*in)
	}
	if in.Int64 != nil {
		in := &in.Int64
		clear(*in)
		map_string_int64_Pool.Put(*in)
	}
	if in.Uint16 != nil {
		in := &in.Uint16
		clear(*in)
		map_string_uint16_Pool.Put(*in)
	}
	if in.Uint32 != nil {
		in := &in.Uint32
		clear(*in)
		map_string_uint32_Pool.Put(*in)
	}
	if in.Uint64 != nil {
		in := &in.Uint64
		clear(*in)
		map_string_uint64_Pool.Put(*in)
	}
	if in.Float32 != nil {
		in := &in.Float32
		clear(*in)
		map_string_float32_Pool.Put(*in)
	}
	if in.Float64 != nil {
		in := &in.Float64
		clear(*in)
		map_string_float64_Pool.Put(*in)
	}
	if in.String != nil {
		in := &in.String
		clear(*in)
		map_string_string_Pool.Put(*in)
	}
	if in.StringPtr != nil {
		in := &in.StringPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				stringp_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_stringp__Pool.Put(*in)
	}
	if in.StringPtrPtr != nil {
		in := &in.StringPtrPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				if **in != nil {
					in := *in
					stringp_Pool.Put(*in)
					*in = nil
				}
				stringp_p_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_stringp_p__Pool.Put(*in)
	}
	if in.Map != nil {
		in := &in.Map
		for _, val := range *in {
			if val != nil {
				in := &val
				clear(*in)
				map_string_string_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_map_string_string__Pool.Put(*in)
	}
	if in.MapPtr != nil {
		in := &in.MapPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				if **in != nil {
					in := *in
					clear(*in)
					map_string_string_Pool.Put(*in)
					*in = nil
				}
				map_string_string_p_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_map_string_string_p__Pool.Put(*in)
	}
	if in.Slice != nil {
		in := &in.Slice
		for _, val := range *in {
			if cap(val) != 0 {
				in := &val
				s_stringSPool.Put(*in)
			}
		}
		clear(*in)
		map_string_s_string_Pool.Put(*in)
	}
	if in.SlicePtr != nil {
		in := &in.SlicePtr
		for _, val := range *in {
			if val != nil {
				in := &val
				if **in != nil {
					in := *in
					s_stringSPool.Put(*in)
					*in = nil
				}
				s_stringp_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_s_stringp__Pool.Put(*in)
	}
	if in.Struct != nil {
		in := &in.Struct
		for _, val := range *in {
			val.ResetNoSelf()
		}
		clear(*in)
		map_string_Ttest_Pool.Put(*in)
	}
	if in.StructPtr != nil {
		in := &in.StructPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				(*in).ResetNoSelf()
				Ttestp_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_Ttestp__Pool.Put(*in)
	}
	if in.StructTest2 != nil {
		in := &in.StructTest2
		clear(*in)
		map_string_Test2_Pool.Put(*in)
	}
	*in = Ttest{}
	TtestPool.Put(in)
}

// ResetNoSelf puts the given field value back into the pool.
func (in *Ttest) ResetNoSelf() {
	if in == nil {
		return
	}
	if in.Byte != nil {
		in := &in.Byte
		clear(*in)
		map_string_byte_Pool.Put(*in)
	}
	if in.Uint8 != nil {
		in := &in.Uint8
		clear(*in)
		map_string_uint8_Pool.Put(*in)
	}
	if in.Int8 != nil {
		in := &in.Int8
		clear(*in)
		map_string_int8_Pool.Put(*in)
	}
	if in.Int16 != nil {
		in := &in.Int16
		clear(*in)
		map_string_int16_Pool.Put(*in)
	}
	if in.Int32 != nil {
		in := &in.Int32
		clear(*in)
		map_string_int32_Pool.Put(*in)
	}
	if in.Int64 != nil {
		in := &in.Int64
		clear(*in)
		map_string_int64_Pool.Put(*in)
	}
	if in.Uint16 != nil {
		in := &in.Uint16
		clear(*in)
		map_string_uint16_Pool.Put(*in)
	}
	if in.Uint32 != nil {
		in := &in.Uint32
		clear(*in)
		map_string_uint32_Pool.Put(*in)
	}
	if in.Uint64 != nil {
		in := &in.Uint64
		clear(*in)
		map_string_uint64_Pool.Put(*in)
	}
	if in.Float32 != nil {
		in := &in.Float32
		clear(*in)
		map_string_float32_Pool.Put(*in)
	}
	if in.Float64 != nil {
		in := &in.Float64
		clear(*in)
		map_string_float64_Pool.Put(*in)
	}
	if in.String != nil {
		in := &in.String
		clear(*in)
		map_string_string_Pool.Put(*in)
	}
	if in.StringPtr != nil {
		in := &in.StringPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				stringp_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_stringp__Pool.Put(*in)
	}
	if in.StringPtrPtr != nil {
		in := &in.StringPtrPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				if **in != nil {
					in := *in
					stringp_Pool.Put(*in)
					*in = nil
				}
				stringp_p_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_stringp_p__Pool.Put(*in)
	}
	if in.Map != nil {
		in := &in.Map
		for _, val := range *in {
			if val != nil {
				in := &val
				clear(*in)
				map_string_string_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_map_string_string__Pool.Put(*in)
	}
	if in.MapPtr != nil {
		in := &in.MapPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				if **in != nil {
					in := *in
					clear(*in)
					map_string_string_Pool.Put(*in)
					*in = nil
				}
				map_string_string_p_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_map_string_string_p__Pool.Put(*in)
	}
	if in.Slice != nil {
		in := &in.Slice
		for _, val := range *in {
			if cap(val) != 0 {
				in := &val
				s_stringSPool.Put(*in)
			}
		}
		clear(*in)
		map_string_s_string_Pool.Put(*in)
	}
	if in.SlicePtr != nil {
		in := &in.SlicePtr
		for _, val := range *in {
			if val != nil {
				in := &val
				if **in != nil {
					in := *in
					s_stringSPool.Put(*in)
					*in = nil
				}
				s_stringp_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_s_stringp__Pool.Put(*in)
	}
	if in.Struct != nil {
		in := &in.Struct
		for _, val := range *in {
			val.ResetNoSelf()
		}
		clear(*in)
		map_string_Ttest_Pool.Put(*in)
	}
	if in.StructPtr != nil {
		in := &in.StructPtr
		for _, val := range *in {
			if val != nil {
				in := &val
				(*in).ResetNoSelf()
				Ttestp_Pool.Put(*in)
			}
		}
		clear(*in)
		map_string_Ttestp__Pool.Put(*in)
	}
	if in.StructTest2 != nil {
		in := &in.StructTest2
		clear(*in)
		map_string_Test2_Pool.Put(*in)
	}
}

// ResetOnlySelf puts the given value back into the pool.
func (in *Ttest) ResetOnlySelf() {
	if in == nil {
		return
	}
	*in = Ttest{}
	TtestPool.Put(in)
}

var stringp_p_Pool = sync.Pool{New: func() any { return new(*string) }}
var s_stringp_Pool = sync.Pool{New: func() any { return new([]string) }}
var Ttestp_Pool = sync.Pool{New: func() any { return new(Ttest) }}
var map_string_string_p_Pool = sync.Pool{New: func() any { return new(map[string]string) }}
var stringp_Pool = sync.Pool{New: func() any { return new(string) }}
var Test2Pool = sync.Pool{New: func() any { return new(Test2) }}
var TtestPool = sync.Pool{New: func() any { return new(Ttest) }}
var map_string_stringp_p__Pool = sync.Pool{New: func() any { return make(map[string]**string, 16) }}
var map_string_s_stringp__Pool = sync.Pool{New: func() any { return make(map[string]*[]string, 16) }}
var map_string_Ttestp__Pool = sync.Pool{New: func() any { return make(map[string]*Ttest, 16) }}
var map_string_map_string_string_p__Pool = sync.Pool{New: func() any { return make(map[string]*map[string]string, 16) }}
var map_string_stringp__Pool = sync.Pool{New: func() any { return make(map[string]*string, 16) }}
var map_string_s_string_Pool = sync.Pool{New: func() any { return make(map[string][]string, 16) }}
var map_string_byte_Pool = sync.Pool{New: func() any { return make(map[string]byte, 16) }}
var map_string_float32_Pool = sync.Pool{New: func() any { return make(map[string]float32, 16) }}
var map_string_float64_Pool = sync.Pool{New: func() any { return make(map[string]float64, 16) }}
var map_string_Test2_Pool = sync.Pool{New: func() any { return make(map[string]Test2, 16) }}
var map_string_Ttest_Pool = sync.Pool{New: func() any { return make(map[string]Ttest, 16) }}
var map_string_int16_Pool = sync.Pool{New: func() any { return make(map[string]int16, 16) }}
var map_string_int32_Pool = sync.Pool{New: func() any { return make(map[string]int32, 16) }}
var map_string_int64_Pool = sync.Pool{New: func() any { return make(map[string]int64, 16) }}
var map_string_int8_Pool = sync.Pool{New: func() any { return make(map[string]int8, 16) }}
var map_string_map_string_string__Pool = sync.Pool{New: func() any { return make(map[string]map[string]string, 16) }}
var map_string_string_Pool = sync.Pool{New: func() any { return make(map[string]string, 16) }}
var map_string_uint16_Pool = sync.Pool{New: func() any { return make(map[string]uint16, 16) }}
var map_string_uint32_Pool = sync.Pool{New: func() any { return make(map[string]uint32, 16) }}
var map_string_uint64_Pool = sync.Pool{New: func() any { return make(map[string]uint64, 16) }}
var map_string_uint8_Pool = sync.Pool{New: func() any { return make(map[string]uint8, 16) }}
var s_stringSPool = newSlicePool[string]()

type slice struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

type slicePool[T any] struct {
	pools [32]sync.Pool
}

func newSlicePool[T any]() slicePool[T] {
	return slicePool[T]{}
}

func index(n uint32) uint32 {
	return uint32(bits.Len32(n - 1))
}

func (p *slicePool[T]) Get(size int) []T {
	c := size
	// Small memory allocation is too scattered. the reuse rate is relatively high, types start with len=16
	if c < 16 {
		c = 16
	}
	idx := index(uint32(c))
	if v := p.pools[idx].Get(); v != nil {
		bp := v.(unsafe.Pointer)
		x := (*int32)(bp)
		c := *x
		*x = 0
		s := &slice{
			Data: bp,
			Len:  size,
			Cap:  int(c),
		}
		return *(*[]T)(unsafe.Pointer(s))
	}
	return make([]T, size, 1<<idx)
}

func (p *slicePool[T]) Put(value []T) {
	c := cap(value)
	if c < 16 {
		return
	}
	idx := index(uint32(c))
	// []T not obtained by Get is placed in the Pool of the previous index
	if c != 1<<idx {
		idx--
	}
	clear(value)
	slice := (*slice)(unsafe.Pointer(&value))
	x := (*int32)(slice.Data)
	*x = int32(c)
	p.pools[idx].Put(slice.Data)
}
